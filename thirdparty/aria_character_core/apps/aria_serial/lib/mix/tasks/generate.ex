# Copyright (c) 2025-present K. S. Ernest (iFire) Lee

defmodule Mix.Tasks.Generate.Serial do
  @moduledoc "Generate industrial-grade serial numbers for Aria project files.\n\n## Usage\n\n    mix generate.serial\n    mix generate.serial --dir lib/aria_engine/membrane/\n    mix generate.serial --dry-run\n\n## Serial Number Format\n\nGenerates serial numbers in standard format: `[F][YY][W][UUU][MMMM]`\n\n- F: Factory/Organization (R=aRia Character Core)\n- YY: Year (25=2025)\n- W: Week (encoded using standard system)\n- UUU: Sequential unit number (001, 002, etc.)\n- MMMM: Tool code derived from filename\n\n## Features\n\n- Scans Elixir files in specified directory\n- Generates unique serial numbers following character validation rules\n- Adds @serial_number module attribute to each file\n- Updates module documentation with serial information\n- Backs up original files before modification\n- Blocks deps folder from processing\n- Uses Timex for accurate date calculations\n\n## Examples\n\n    # Generate serials for membrane files\n    mix generate.serial --dir lib/aria_engine/membrane/\n\n    # Generate serials for migration tools\n    mix generate.serial --dir lib/mix/tasks/migrate/\n\n    # Preview changes without applying them\n    mix generate.serial --dir lib/aria_engine/ --dry-run\n\n    # Generate for current directory\n    mix generate.serial\n"
  use Mix.Task
  alias AriaSerial.Registry
  @shortdoc "Generate industrial-grade serial numbers for project files"
  @switches dry_run: :boolean, help: :boolean, dir: :string
  @aliases d: :dry_run, h: :help
  def run(args) do
    {opts, _args, _invalid} = OptionParser.parse(args, switches: @switches, aliases: @aliases)

    if opts[:help] do
      show_help()
    else
      generate_serials(opts)
    end
  end

  defp generate_serials(opts) do
    factory = "R"
    dry_run = opts[:dry_run] || false
    target_dir = opts[:dir] || "."
    Mix.shell().info("Generating industrial-grade serial numbers for project files...")
    Mix.shell().info("Factory: #{decode_factory(factory)}")
    Mix.shell().info("Target Directory: #{target_dir}")

    Mix.shell().info(
      "Mode: #{if dry_run do
        "DRY RUN"
      else
        "LIVE"
      end}"
    )

    Mix.shell().info("")
    files = find_elixir_files(target_dir)

    if Enum.empty?(files) do
      Mix.shell().info("No Elixir files found in #{target_dir}")
      :ok
    else
      current_week = get_current_week()
      year = get_current_year()
      Mix.shell().info("Current week: #{current_week} (#{year})")
      Mix.shell().info("Found #{length(files)} Elixir files:")
      Mix.shell().info("")

      files
      |> Enum.with_index(1)
      |> Enum.each(fn {file, index} ->
        process_file(file, factory, year, current_week, index, dry_run)
      end)

      if dry_run do
        Mix.shell().info("")
        Mix.shell().info("DRY RUN completed. No files were modified.")
        Mix.shell().info("Run without --dry-run to apply changes.")
      else
        Mix.shell().info("")
        Mix.shell().info("Serial numbers generated successfully!")
        Mix.shell().info("Use 'mix serial.decode <serial>' to decode any serial number.")
      end
    end
  end

  defp find_elixir_files(dir) do
    if File.exists?(dir) do
      find_elixir_files_recursive(dir)
      |> Enum.reject(&is_deps_file?/1)
      |> Enum.reject(&has_serial_number?/1)
    else
      []
    end
  end

  defp find_elixir_files_recursive(dir) do
    dir
    |> File.ls!()
    |> Enum.flat_map(fn item ->
      path = Path.join(dir, item)

      cond do
        File.dir?(path) -> find_elixir_files_recursive(path)
        String.ends_with?(item, ".ex") and not String.starts_with?(item, ".") -> [path]
        true -> []
      end
    end)
  end

  defp is_deps_file?(file_path) do
    String.contains?(file_path, "/deps/") or String.contains?(file_path, "\\deps\\")
  end

  defp has_serial_number?(file_path) do
    case File.read(file_path) do
      {:ok, content} -> String.contains?(content, "@serial_number")
      {:error, _} -> false
    end
  end

  defp process_file(file_path, factory, year, week, sequence, dry_run) do
    filename = Path.basename(file_path)
    tool_code = Registry.generate_tool_code(filename)

    Mix.shell().info("#{sequence}. #{filename}")
    Mix.shell().info("   Tool Code: #{tool_code}")
    Mix.shell().info("   Path: #{file_path}")

    if dry_run do
      # For dry run, generate serial the old way for preview
      week_char = Registry.encode_week(week)
      serial = generate_serial(factory, year, week_char, sequence, tool_code)
      Mix.shell().info("   Serial: #{serial}")
      Mix.shell().info("   [DRY RUN] Would add serial number and register in lookup")
    else
      # Use atomic generation and registration
      file_info = %{
        "format" => "v1",
        "file" => filename,
        "purpose" => "Generated by mix generate.serial",
        "created" => Date.to_iso8601(Date.utc_today()),
        "week" => week,
        "sequence" => sequence
      }

      case AriaSerial.JsonStorage.generate_and_register_serial(year, week, factory, tool_code, file_info) do
        {:ok, serial} ->
          Mix.shell().info("   Serial: #{serial}")
          case add_serial_to_file(file_path, serial) do
            :ok ->
              Mix.shell().info("   ‚úÖ Serial number added and registered in lookup")
            {:error, reason} ->
              Mix.shell().error("   ‚ùå File injection failed: #{reason}")
              Mix.shell().error("   ‚ö†Ô∏è  Serial #{serial} was registered but not added to file")
          end
        {:error, reason} ->
          Mix.shell().error("   ‚ùå Failed to generate/register serial: #{inspect(reason)}")
      end
    end

    Mix.shell().info("")
  end

  defp generate_serial(factory, year, week_char, sequence, tool_code) do
    year_str = String.slice(to_string(year), -2, 2)
    sequence_str = String.pad_leading(to_string(sequence), 3, "0")
    "#{factory}#{year_str}#{week_char}#{sequence_str}#{tool_code}"
  end

  defp add_serial_to_file(file_path, serial) do
    with {:ok, content} <- File.read(file_path),
         {:ok, backup_path} <- create_backup(file_path),
         {:ok, new_content} <- inject_serial(content, serial),
         :ok <- File.write(file_path, new_content) do
      Mix.shell().info("   üìÅ Backup: #{backup_path}")
      :ok
    else
      {:error, reason} -> {:error, reason}
    end
  end

  defp create_backup(file_path) do
    backup_path = file_path <> ".bak"

    case File.copy(file_path, backup_path) do
      {:ok, _} -> {:ok, backup_path}
      {:error, reason} -> {:error, "Failed to create backup: #{reason}"}
    end
  end

  defp inject_serial(content, serial) do
    lines = String.split(content, "\n")

    case find_injection_point(lines) do
      {:moduledoc, line_index} -> inject_after_moduledoc(lines, line_index, serial)
      {:defmodule, line_index} -> inject_after_defmodule(lines, line_index, serial)
      :not_found -> {:error, "Could not find suitable injection point"}
    end
  end

  defp find_injection_point(lines) do
    lines
    |> Enum.with_index()
    |> Enum.find_value(fn {line, index} ->
      cond do
        String.contains?(line, "@moduledoc") -> find_moduledoc_end(lines, index)
        String.contains?(line, "defmodule") -> {:defmodule, index}
        true -> nil
      end
    end) || :not_found
  end

  defp find_moduledoc_end(lines, start_index) do
    lines
    |> Enum.drop(start_index)
    |> Enum.with_index(start_index)
    |> Enum.find_value(fn {line, index} ->
      if String.contains?(line, "\"\"\"") and index > start_index do
        {:moduledoc, index}
      end
    end)
  end

  defp inject_after_moduledoc(lines, moduledoc_end_index, serial) do
    {before, after_lines} = Enum.split(lines, moduledoc_end_index + 1)
    serial_lines = ["", "  @serial_number \"#{serial}\"", ""]
    new_content = (before ++ serial_lines ++ after_lines) |> Enum.join("\n")
    {:ok, new_content}
  end

  defp inject_after_defmodule(lines, defmodule_index, serial) do
    {before, after_lines} = Enum.split(lines, defmodule_index + 1)

    serial_lines = [
      "  @moduledoc \"\"\"",
      "  Project file with serial number: #{serial}",
      "",
      "  Decode: mix serial.decode #{serial}",
      "  \"\"\"",
      "",
      "  @serial_number \"#{serial}\"",
      ""
    ]

    new_content = (before ++ serial_lines ++ after_lines) |> Enum.join("\n")
    {:ok, new_content}
  end

  defp get_current_week do
    if Code.ensure_loaded?(Timex) do
      Timex.iso_week(Date.utc_today()) |> elem(1)
    else
      today = Date.utc_today()
      start_of_year = Date.new!(today.year, 1, 1)
      days_diff = Date.diff(today, start_of_year)
      div(days_diff, 7) + 1
    end
  end

  defp get_current_year do
    Date.utc_today().year
  end

  defp decode_factory("R") do
    "aRia Character Core"
  end

  defp decode_factory(f) do
    "Unknown Factory (#{f})"
  end

  defp show_help do
    Mix.shell().info(@moduledoc)
  end
end
